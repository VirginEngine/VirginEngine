export const core = "const ctx = document.body.children[0].getContext(`2d`)\nfunction onresize() {\nctx.canvas.width = window.innerWidth\nctx.canvas.height = window.innerHeight\n}\nwindow.addEventListener(`resize`, onresize)\nonresize()\nconst files = `REPLACE_FILES`\nlet scene = {}\nconst events = {}\nconst eventsHover = {}\nwindow.addEventListener(`mousedown`, () => (eventsHover.click = true))\nwindow.addEventListener(`mouseup`, () => delete eventsHover.click)\nwindow.addEventListener(`click`, () => (events.click = true))\nwindow.addEventListener(`keydown`, ({ key }) => (events[key] = eventsHover[key] = true))\nwindow.addEventListener(`keyup`, ({ key }) => delete eventsHover[key])\nwindow.addEventListener(`contextmenu`, (e) => {\ne.preventDefault()\n!document.fullscreenElement ? document.documentElement.requestFullscreen() : document.exitFullscreen()\n})\nconst GameTime = {\nms: 1,\nvalue: 1,\nlastTime: 0,\nget() {\nreturn GameTime.value\n},\nset(newTime) {\nGameTime.value = newTime\nGameTime.ms = 1000 / (60 * GameTime.value)\nGameTime.lastTime = performance.now()\n},\n}\nconst Log = { updates: 0, frames: 0, framesTemp: 0 }\nconst gameObjects = []\nclass GameObject {\ntoUpdate = []\ntoRender = []\nconstructor({ parent, transform, rect, text, sprite, start, update, render, ...rest }) {\nif (parent) this.parent = parent\nthis.transform = new Transform(transform, this)\nif (text) this.text = new Text(text, this, rect)\nif (sprite) this.sprite = new Sprite(sprite, this)\nfor (const key in rest) {\nif (isChildKey(key)) {\nthis[key] = new GameObject({ ...rest[key], parent: this })\n} else {\nthis[key] = typeof rest[key] === `function` ? rest[key].bind(this) : rest[key]\n}\n}\nif (update) this.toUpdate.push(update.bind(this))\nif (render) this.toRender.push(render.bind(this))\nif (start) {\nthis.start = start.bind(this)\nthis.start()\n}\ngameObjects.push(this)\n}\nget childs() {\nconst childs = []\nfor (const key in this) {\nif (isChildKey(key)) childs.push(this[key])\n}\nreturn childs\n}\nget name() {\nfor (const key in this.parent) {\nif (this === this.parent[key]) return key\n}\n}\nget props() {\nconst newObj = {\nstart: this?.start,\nupdate: this?.update,\ntransform: {\nposition: this.position,\nrotation: this.rotation,\nscale: this.scale,\n},\n}\nreturn deepCopy(newObj)\n}\nstatic destroy(obj) {\nfor (const child of obj.childs) GameObject.destroy(child)\nconst { parent } = obj\nlet parentKey = ``\nfor (const key in obj.parent) {\nif (obj.parent[key] === obj) {\nparentKey = key\nbreak\n}\n}\nfor (const key in obj) delete obj[key]\ngameObjects.splice(gameObjects.indexOf(obj))\ndelete parent[parentKey]\n}\n}\nclass Transform {\ngameObject = null\npositionX = 0\npositionY = 0\nrotationZ = 0\nscaleX = 1\nscaleY = 1\nconstructor(props, gameObject) {\nif (props) {\nthis.gameObject = gameObject\nconst { position, rotation, scale, rect } = props\nif (rect) this.rect = rect\nthis.position = position\nthis.rotation = rotation\nthis.scale = scale\ngameObject.position = position\ngameObject.rotation = rotation\ngameObject.scale = scale\n} else {\nthis.readOnly = true\n}\n}\nget position() {\nreturn { x: this.positionX, y: this.positionY }\n}\nset position({ x, y }) {\nif (this.readOnly) {\nalert(`PROGRAMMER, you can't chage \"readOnly\" position`)\nreturn\n}\nfor (const child of this.gameObject.childs) {\nchild.transform.position = {\nx: child.transform.positionX - this.positionX + x,\ny: child.transform.positionY - this.positionY + y,\n}\n}\nthis.positionX = x\nthis.positionY = y\n}\nget rotation() {\nreturn { z: this.rotationZ }\n}\nset rotation({ z }) {\nif (this.readOnly) {\nalert(`PROGRAMMER, you can't chage \"readOnly\" rotation`)\nreturn\n}\nwhile (z < 0) {\nz += 360\n}\nwhile (z > 360) {\nz -= 360\n}\nfor (const child of this.gameObject.childs) {\nlet newRot = child.transform.rotationZ - this.rotationZ + z\nif (newRot < 0) {\nnewRot += 360\n} else if (newRot > 360) {\nnewRot -= 360\n}\nchild.transform.rotation = { z: newRot }\n}\nthis.rotationZ = z\n}\nget scale() {\nreturn { x: this.scaleX, y: this.scaleY }\n}\nset scale({ x, y }) {\nif (this.readOnly) {\nalert(`PROGRAMMER, you can't chage \"readOnly\" scale`)\nreturn\n}\nfor (const child of this.gameObject.childs) {\nchild.transform.scale = {\nx: (child.transform.scaleX / this.scaleX) * x,\ny: (child.transform.scaleY / this.scaleY) * y,\n}\n}\nthis.scaleX = x\nthis.scaleY = y\n}\n}\nclass Collider {\nconstructor() {}\n}\nclass Physics {\nconstructor() {}\n}\nclass Sprite {\nconstructor({ color }, gameObject) {\nthis.gameObject = gameObject\nthis.color = color\ngameObject.toRender.push(this.render.bind(this))\n}\nrender() {\ndraw({\nx: this.gameObject.position.x,\ny: this.gameObject.position.y,\nw: this.gameObject.scale.x,\nh: this.gameObject.scale.y,\ncolor: this.color,\n})\n}\n}\nclass Animation {\nconstructor() {}\n}\nclass Text {\nvalue = ``\nrect = undefined\ntransform = undefined\nconstructor({ value }, gameObject, rect) {\nthis.transform = gameObject.transform\nthis.value = value\nthis.textBaseline = Text.textBaseline[rect.x]\nthis.textAlign = Text.textAlign[rect.y]\ngameObject.toRender.push(this.render.bind(this))\n}\nrender() {\ndraw({\ntext: this.value,\n...this.transform.position,\nfillStyle: `white`,\nfont: `${this.transform.scale.y}px serif`,\ntextBaseline: this.textBaseline,\ntextAlign: this.textAlign,\n})\n}\nstatic textBaseline = [`top`, `middle`, `bottom`]\nstatic textAlign = [`left`, `center`, `right`]\n}\nasync function wait(time) {\nawait new Promise((r) => setTimeout(r, time))\n}\nasync function wait0() {\nawait new Promise((r) => setTimeout(r))\n}\nfunction isChildKey(text) {\nreturn `ABCDEFGHIJKLMNOPRQSTUWXYZ`.includes(text[0])\n}\nfunction deepCopy(data) {\nif (Array.isArray(data)) {\nreturn data.reduce((prev, val) => [...prev, deepCopy(val)], [])\n}\nif (typeof data === `object`) {\nconst newObj = {}\nfor (const key in data) {\nnewObj[key] = deepCopy(data[key])\n}\nreturn newObj\n}\nreturn data\n}\nfunction clone(obj, parent) {\nconst name = obj.name\nlet newName = name\nlet i = 0\nwhile (parent[newName]) {\nnewName = `${name}${i}`\ni++\n}\nparent[newName] = new GameObject({ ...obj.props, parent })\n}\nfunction loadScene(newScene) {\ngameObjects.length = 0\nscene = new GameObject(deepCopy(newScene))\nfor (const key in events) delete events[key]\nfor (const key in eventsHover) delete eventsHover[key]\n}\nfunction draw({ text, color, x, y, w, h, ...props }) {\nctx.save()\nfor (const key in props) {\nctx[key] = props[key]\n}\nif (text) ctx.fillText(text, x, y)\nif (color) {\nctx.fillStyle = color\nctx.fillRect(x, y, w, h)\n}\nctx.restore()\n}\nfunction drawBoxMiddle(x, y, w, h, color) {\nif (color) ctx.fillStyle = color\nctx.fillRect(x, y, w, h)\n}\nasync function run() {\nGameTime.set(1)\nrequestAnimationFrame(render)\nlet timer = performance.now()\nlet updates = 0\nlet delta = 0\nwhile (true) {\nconst now = performance.now()\ndelta += (now - GameTime.lastTime) / GameTime.ms\nif (delta > 60) delta = 60\nGameTime.lastTime = now\nwhile (delta >= 1) {\nupdate()\nupdates++\ndelta--\n}\nif (now - timer > 1000) {\ntimer += 1000\nLog.updates = updates\nLog.frames = Log.framesTemp\nupdates = 0\nLog.framesTemp = 0\n}\nawait wait0()\n}\n}\nfunction update() {\nfor (const obj of gameObjects) {\nfor (const f of obj.toUpdate) f()\n}\nfor (const key in events) delete events[key]\n}\nfunction render() {\nctx.fillStyle = `black`\nctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\nfor (const obj of gameObjects) {\nfor (const f of obj.toRender) f()\n}\nconst props = {\nx: 8,\ny: 8,\nfillStyle: `white`,\nfont: `22px serif`,\ntextAlign: `left`,\ntextBaseline: `top`,\n}\ndraw({ text: `Update ${Log.updates}`, ...props })\ndraw({ text: `Render ${Log.frames}`, ...props, y: 38 })\nLog.framesTemp++\nrequestAnimationFrame(render)\n}\nloadScene(`REPLACE_PATH_TO_MAIN_SCENE`)\nrun()"